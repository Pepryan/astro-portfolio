---
title: "React Performance Optimization: Advanced Techniques"
date: "2024-12-05"
tags: ["react", "performance", "optimization", "frontend", "javascript"]
category: "Frontend Development"
summary: "Deep dive into advanced React performance optimization techniques including memoization, code splitting, and profiling."
author: "Febryan Ramadhan"
difficulty: "Intermediate"
keywords: ["react", "performance", "optimization", "memoization", "code splitting"]
draft: true

openGraph:
  title: "React Performance Optimization: Advanced Techniques"
  description: "Master React performance optimization with advanced techniques for building lightning-fast applications."
  type: "article"
twitter:
  card: "summary_large_image"
  title: "React Performance Optimization: Advanced Techniques"
  description: "Master React performance optimization with advanced techniques for building lightning-fast applications."
schema:
  type: "BlogPosting"
  author:
    name: "Febryan Ramadhan"
    url: "https://febryan.web.id"
  publisher:
    name: "Febryan Blog"
    url: "https://febryan.web.id"
---

# Mastering React Performance Optimization

React applications can become slow as they grow in complexity. This guide covers advanced techniques to keep your React apps fast and responsive.

## Understanding React's Rendering Process

### The Reconciliation Algorithm

React uses a diffing algorithm to determine what changes need to be made to the DOM:

1. **Virtual DOM comparison** between current and previous states
2. **Fiber architecture** for incremental rendering
3. **Priority-based scheduling** for smooth user interactions

### Common Performance Bottlenecks

- **Unnecessary re-renders** of components
- **Large bundle sizes** affecting initial load
- **Inefficient state updates** causing cascading renders
- **Memory leaks** from improper cleanup

## Memoization Techniques

### React.memo for Component Memoization

```jsx
import React, { memo } from 'react';

const ExpensiveComponent = memo(({ data, onUpdate }) => {
  // Expensive calculations or rendering
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      processed: expensiveCalculation(item)
    }));
  }, [data]);

  return (
    <div>
      {processedData.map(item => (
        <div key={item.id}>{item.processed}</div>
      ))}
    </div>
  );
});

// Custom comparison function for complex props
const areEqual = (prevProps, nextProps) => {
  return (
    prevProps.data.length === nextProps.data.length &&
    prevProps.data.every((item, index) => 
      item.id === nextProps.data[index].id &&
      item.value === nextProps.data[index].value
    )
  );
};

export default memo(ExpensiveComponent, areEqual);
```

### useMemo and useCallback Hooks

```jsx
import React, { useMemo, useCallback, useState } from 'react';

const OptimizedComponent = ({ items, filter }) => {
  const [sortOrder, setSortOrder] = useState('asc');

  // Memoize expensive calculations
  const filteredAndSortedItems = useMemo(() => {
    const filtered = items.filter(item => 
      item.name.toLowerCase().includes(filter.toLowerCase())
    );
    
    return filtered.sort((a, b) => {
      const modifier = sortOrder === 'asc' ? 1 : -1;
      return a.name.localeCompare(b.name) * modifier;
    });
  }, [items, filter, sortOrder]);

  // Memoize event handlers
  const handleSortChange = useCallback((newOrder) => {
    setSortOrder(newOrder);
  }, []);

  const handleItemClick = useCallback((itemId) => {
    // Handle item click
    console.log('Item clicked:', itemId);
  }, []);

  return (
    <div>
      <SortControls onSortChange={handleSortChange} />
      <ItemList 
        items={filteredAndSortedItems}
        onItemClick={handleItemClick}
      />
    </div>
  );
};
```

## Code Splitting and Lazy Loading

### Route-Based Code Splitting

```jsx
import React, { Suspense, lazy } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';

// Lazy load route components
const Home = lazy(() => import('./pages/Home'));
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Profile = lazy(() => import('./pages/Profile'));

// Loading component
const LoadingSpinner = () => (
  <div className="flex items-center justify-center min-h-screen">
    <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-blue-500"></div>
  </div>
);

const App = () => {
  return (
    <Router>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/profile" element={<Profile />} />
        </Routes>
      </Suspense>
    </Router>
  );
};
```

### Component-Based Code Splitting

```jsx
import React, { useState, Suspense, lazy } from 'react';

// Lazy load heavy components
const HeavyChart = lazy(() => import('./HeavyChart'));
const DataTable = lazy(() => import('./DataTable'));

const Dashboard = () => {
  const [activeTab, setActiveTab] = useState('overview');

  return (
    <div>
      <nav>
        <button onClick={() => setActiveTab('overview')}>Overview</button>
        <button onClick={() => setActiveTab('charts')}>Charts</button>
        <button onClick={() => setActiveTab('data')}>Data</button>
      </nav>

      <div className="tab-content">
        {activeTab === 'overview' && <OverviewComponent />}
        
        {activeTab === 'charts' && (
          <Suspense fallback={<div>Loading charts...</div>}>
            <HeavyChart />
          </Suspense>
        )}
        
        {activeTab === 'data' && (
          <Suspense fallback={<div>Loading data table...</div>}>
            <DataTable />
          </Suspense>
        )}
      </div>
    </div>
  );
};
```

## State Management Optimization

### Reducing State Updates

```jsx
import React, { useReducer, useCallback } from 'react';

// Use reducer for complex state logic
const todoReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [...state.todos, action.payload],
        lastUpdated: Date.now()
      };
    
    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        ),
        lastUpdated: Date.now()
      };
    
    case 'BATCH_UPDATE':
      return {
        ...state,
        todos: action.payload,
        lastUpdated: Date.now()
      };
    
    default:
      return state;
  }
};

const TodoApp = () => {
  const [state, dispatch] = useReducer(todoReducer, {
    todos: [],
    lastUpdated: null
  });

  // Batch multiple updates
  const batchUpdateTodos = useCallback((updates) => {
    const updatedTodos = state.todos.map(todo => {
      const update = updates.find(u => u.id === todo.id);
      return update ? { ...todo, ...update } : todo;
    });
    
    dispatch({ type: 'BATCH_UPDATE', payload: updatedTodos });
  }, [state.todos]);

  return (
    <div>
      <TodoList todos={state.todos} dispatch={dispatch} />
      <BatchUpdateControls onBatchUpdate={batchUpdateTodos} />
    </div>
  );
};
```

### Context Optimization

```jsx
import React, { createContext, useContext, useMemo } from 'react';

// Split contexts by update frequency
const UserContext = createContext();
const ThemeContext = createContext();
const NotificationContext = createContext();

// Memoize context values
const AppProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  const [notifications, setNotifications] = useState([]);

  // Memoize context values to prevent unnecessary re-renders
  const userValue = useMemo(() => ({
    user,
    setUser,
    isAuthenticated: !!user
  }), [user]);

  const themeValue = useMemo(() => ({
    theme,
    setTheme,
    isDark: theme === 'dark'
  }), [theme]);

  const notificationValue = useMemo(() => ({
    notifications,
    addNotification: (notification) => {
      setNotifications(prev => [...prev, notification]);
    },
    removeNotification: (id) => {
      setNotifications(prev => prev.filter(n => n.id !== id));
    }
  }), [notifications]);

  return (
    <UserContext.Provider value={userValue}>
      <ThemeContext.Provider value={themeValue}>
        <NotificationContext.Provider value={notificationValue}>
          {children}
        </NotificationContext.Provider>
      </ThemeContext.Provider>
    </UserContext.Provider>
  );
};
```

## Performance Profiling

### Using React DevTools Profiler

```jsx
import React, { Profiler } from 'react';

const onRenderCallback = (id, phase, actualDuration, baseDuration, startTime, commitTime) => {
  console.log('Profiler:', {
    id,
    phase, // 'mount' or 'update'
    actualDuration, // Time spent rendering
    baseDuration, // Estimated time without memoization
    startTime,
    commitTime
  });
};

const App = () => {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <Header />
      <Main />
      <Footer />
    </Profiler>
  );
};
```

### Custom Performance Monitoring

```jsx
import React, { useEffect } from 'react';

const usePerformanceMonitor = (componentName) => {
  useEffect(() => {
    const startTime = performance.now();
    
    return () => {
      const endTime = performance.now();
      const renderTime = endTime - startTime;
      
      if (renderTime > 16) { // More than one frame
        console.warn(`${componentName} took ${renderTime}ms to render`);
      }
    };
  });
};

const MonitoredComponent = () => {
  usePerformanceMonitor('MonitoredComponent');
  
  // Component logic here
  return <div>Content</div>;
};
```

## Bundle Optimization

### Webpack Bundle Analysis

```bash
# Install bundle analyzer
npm install --save-dev webpack-bundle-analyzer

# Add to package.json scripts
"analyze": "npm run build && npx webpack-bundle-analyzer build/static/js/*.js"

# Run analysis
npm run analyze
```

### Tree Shaking Optimization

```jsx
// Instead of importing entire library
import * as _ from 'lodash';

// Import only what you need
import { debounce, throttle } from 'lodash';

// Or use individual packages
import debounce from 'lodash.debounce';
import throttle from 'lodash.throttle';
```

## Best Practices Summary

1. **Profile before optimizing** - Use React DevTools Profiler
2. **Memoize expensive calculations** with useMemo
3. **Memoize event handlers** with useCallback
4. **Split code at route boundaries** for better loading
5. **Optimize context usage** by splitting contexts
6. **Use proper key props** for list items
7. **Implement virtual scrolling** for large lists
8. **Lazy load heavy components** when needed
9. **Monitor bundle size** regularly
10. **Test performance** on slower devices

## Conclusion

React performance optimization is an ongoing process that requires careful measurement and targeted improvements. By applying these techniques strategically, you can build React applications that remain fast and responsive as they scale.

Remember: premature optimization is the root of all evil. Always measure first, then optimize based on actual performance bottlenecks in your application.
